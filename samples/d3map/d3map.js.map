{"version":3,"sources":["../samples/browser/d3map/d3map.fsx"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAmEI;AAAA;AAAO;AACP;AACJ;AACA;AACI;;AAMA,wCACF,iCAEc,SAFd,EAE0B,UAF1B,SAGS,cAHT,8BADE;;AAQA,4BACF,iDADE;;AAKA,8BAAQ,gCAAR;;AAgCA,wCAYE;AAAA;AAAA,mBAAQ;AAAA;AAAA,KAAR,gBAEc,2CAFd,YAOF,8CApFwC;AAAA,aAqFE;AAAA;AAAA;AAAM,SAAN;AAAM,OArFR;AAAC,KAoFzC,CAPE,cAaF,mCAQM;AAAA,uCAAS,iBAAT,EAAyB,iBAAzB;AAAuC,KAR7C,mEAGI;AAAA,mCACE;AAAA,eAAI,eAAD,KAAiB,eAApB,IACK,eADL;AAEU,OAHZ;AAGa,KANjB,GAbE,SA+BF;AAAA;AAAA;AAAA;AAAA,mBAAa,qBAAb,GACK,uBADL;AAEA;AACA;AAHA;AAKA,mBAAa,UAAb,GAA6B,YAA7B;AAAyC,WALzC;AAKyC,SALzC;AAKyC,OALzC;AAKyC,KApCvC,WAwCA;AAAA;AAAA,yCACA,kCADA,EAEA,qCAFA,EAGA,iCAHA,EAIA,oCAJA,EAKA,gCALA;AAMM,OANN;AAMM,KA9CN,eAyDF;AAAA,gEAtIwC;AAAA,eAwIf;AAAA;AAAA;AAAA,6CAGrB,gBAHqB;AAAC,WAAD;AAAC,SAxIc;AAAC,OAsIzC,kBAvIkC;AAAA,eA6IP;AAAA;AAAA;AAAA,oCAGV,6BAHU,sDAIf,qBAAe,mBAAf,GAAqC,GAArC,EAA0C,GAA1C,EAJe,EA7IO;AAAA,qBAkJjB;AAAA,4CAAsB,IAAtB;AAAkC,eAlJjB;AAAC,aA6IR;AAAC,WAAD;AAAC,SA7IM;AAAC,OAuInC,2BAtIwC;AAAA,eAmJjB;AAAA;AAAA,8BAEP,CAAC,KAAD,oBAFO;AAAC,WAAD;AAAC,SAnJgB;AAAC,OAsIzC;AAe8C,KAxE5C,EA0EJ,aA1EI;AAAK,GAZP;;AAgGJ,iHAhKkD;AAAA,WAsK9C;AAAA;AAAA;AAAA,yBAAc;AAAA;AAAuB,WAAvB,EAAd,SACA,wBADA;AACsB,SADtB;AACsB,OADtB;AACsB,KAvKwB;AAAC,GAgKnD","file":"d3map.js","sourcesContent":["(**\r\n - title: D3 world tour\r\n - tagline: Looping through countries of the world\r\n - app-style: height:500px; width:500px; margin:10px auto 10px auto;\r\n - require-paths: ` 'd3':'https://d3js.org/d3.v3.min' `\r\n - intro: This demo is a Fable port of [Mike Bostock's World Tour](http://bl.ocks.org/mbostock/4183330)\r\n   D3 demo. It uses the D3 library to create a visualization that loops through all countries of\r\n   the world and shows them on the globe one by one.\r\n   You can find the [full source code on GitHub](https://github.com/fsprojects/Fable/blob/master/samples/browser/d3map/d3map.fsx).\r\n\r\n   On the technical side, the demo shows some of the more interesting aspects of\r\n   calling JavaScript libraries from Fable. You'll learn how to define mapping for\r\n   global objects, how to use functions and the `?` operator.\r\n*)\r\n(*** hide ***)\r\n#r \"node_modules/fable-core/Fable.Core.dll\"\r\n#load \"node_modules/fable-import-d3/Fable.Import.D3.fs\"\r\n(**\r\nJavaScript helpers and imports\r\n------------------------------\r\n\r\nFable comes with [an F# mapping for the D3 library](https://github.com/fsprojects/Fable/tree/master/import/d3),\r\nwhich defines all the types and functions for D3 that we'll need in this example. In addition to\r\nD3, this demo uses [d3-queue](https://github.com/d3/d3-queue) and [topojson](https://github.com/mbostock/topojson).\r\nWe'll write the mappings for those two inline\r\n*)\r\nopen System\r\nopen Fable.Core\r\nopen Fable.Import\r\nopen Fable.Import.Browser\r\n\r\n/// Represents the operations of the 'queue' object\r\ntype IQueue =\r\n    abstract member defer: obj * obj -> IQueue\r\n    abstract member await: obj -> unit\r\n\r\n/// Represents the API exposed by Topo JSON\r\ntype ITopojson =\r\n    abstract member feature: obj * obj -> obj\r\n    abstract member mesh: obj * obj * obj -> obj\r\n\r\n// Globally imported JS libs (loaded with <script> tag)\r\nlet [<Global>] queue: unit->IQueue = failwith \"JS only\"\r\nlet [<Global>] topojson: ITopojson = failwith \"JS only\"\r\n(**\r\n\r\nThe `Global` attrobute on the two values specifies that those are imported globally available\r\nvalues. Fable does not generate any JavaScript code for them - it simply maps any call to\r\n`topojson.feature(..)` etc. to a corresponding JavaScript call.\r\n\r\nIn addition to the library imports, we also define the following helpers that wrap an F#\r\nfunction into the `Func<...>` type. This creates a function value that is compatible with\r\nJavaScript. This is needed because F# uses curried representation of functions and so,\r\nfor example, `fun a b -> a + b` would correspond to `function(a){ return function(b) { return a + b; }}`\r\nin JavaScript. The `Func<...>` delegate avoids the issue:\r\n*)\r\nlet inline f1 (f: 'a->'b) = Func<_,_> f\r\nlet inline f2 (f: 'a->'b->'c) = Func<_,_,_> f\r\nlet inline f3 (f: 'a->'b->'c->'d) = Func<_,_,_,_> f\r\n\r\n(**\r\nSetting up the canvas and projection\r\n------------------------------------\r\n\r\nWe will be using D3 together with HTML5 canvas, so the first step is to get the context object\r\nand set the size of the canvas to 500x500:\r\n*)\r\nlet width, height = 500., 500.\r\nlet canvas =  document.getElementsByTagName_canvas().[0]\r\ncanvas.width <- width\r\ncanvas.height <- height\r\nlet ctx = canvas.getContext_2d()\r\n(**\r\nNext, we setup the D3 orthographic projection for the globe. The `projection` object will be\r\nused later for rotating the globe. The `path` value is used for transforming paths that we\r\nwant to render to match with the projection.\r\n*)\r\nlet projection =\r\n  D3.geo\r\n    .orthographic()\r\n    .translate((width / 2., height / 2.))\r\n    .scale(width / 2. - 20.)\r\n    .clipAngle(90.)\r\n    .precision(0.6)\r\n\r\nlet path =\r\n  D3.geo.path()\r\n    .projection(unbox<D3.Geo.Transform> projection)\r\n    .context(ctx)\r\n\r\nlet title = d3.select(\".country-name\")\r\n(**\r\nFinally, the `title` value is the HTML element in the middle of the globe that shows the\r\ncurrent country name. This is just an ordinary HTML element and we will set its body text\r\nduring the animation.\r\n\r\nGenerating the visualization\r\n----------------------------\r\n\r\nThe main part of the code is defined inside a `dataLoaded` function. This gets called\r\nafter D3 loads the country names and locations. The structure of the code looks as follows:\r\n\r\n    let dataLoaded world names =\r\n      // (more definitions and setup)\r\n\r\n      // Generate next transition\r\n      let rec transition (i) =\r\n        // (...)\r\n\r\n      // Start the first transition\r\n      transition (0)\r\n\r\nThe `dataLoaded` function will be called by D3 with a `world` value loaded from the\r\n[world-110m.json](https://github.com/fsprojects/Fable/blob/master/samples/browser/d3map/data/world-110m.json)\r\nfile that represents individual country areas; `names` loads country names from\r\n[world-country-names.tsv](https://github.com/fsprojects/Fable/blob/master/samples/browser/d3/data/world-country-names.tsv).\r\n\r\nAfter some setup, the code defines a recursive `transition` function, which performs one transition\r\nand then calls itself to setup the next transition step. In each step, it increments the index of\r\nthe current country, which is stored in `i`. The `transtion 0` call then starts the animation.\r\n*)\r\n(*** hide ***)\r\nlet dataLoaded world names =\r\n(**\r\n\r\n### Preparing the data\r\n\r\nOnce the data is loaded, we need to do some pre-processing. First, we create a number of\r\nD3 objects that are used to render the map - this includes `globe` for the border around\r\nthe globe, `landFeatures` (for filling land) and `borders` for rendering borders between\r\ncouuntries. We also find all countries for which we have both name and map:\r\n\r\n*)\r\n  // Create globe object (to render the border)\r\n  let globe = createObj [ \"type\" ==> \"Sphere\" ]\r\n  // Create land feature (fill the world)\r\n  let landFeature = topojson.feature(world, world?objects?``land``)\r\n\r\n  // Used to render country borders, specify filter to\r\n  // prune overlapping borders (shared by 2 countries)\r\n  let borders =\r\n    topojson.mesh(world,\r\n      world?objects?countries, f2 (fun x y -> x <> y))\r\n\r\n  // Get countries for which we have a name and set\r\n  // their name property using the `?` operator\r\n  let countries =\r\n    topojson.feature(world, world?objects?countries)?features\r\n    |> unbox<obj[]>\r\n    |> Array.filter (fun d ->\r\n        names |> Seq.exists (fun n ->\r\n          if (string d?id) = (string n?id)\r\n          then d?name <- n?name; true\r\n          else false))\r\n    |> Array.sortWith (fun a b ->\r\n          compare (string a?name) (string b?name))\r\n(**\r\n\r\n### Rendering the map\r\n\r\nNow we have all we need to render the map! Given a selected country `country` and a\r\nrotation `angle`, the following function renders the map:\r\n*)\r\n  /// Helper that draws or fills a line\r\n  let draw color width line fill =\r\n    if fill then ctx.fillStyle <- U3.Case1 color\r\n    else ctx.strokeStyle <- U3.Case1 color\r\n    ctx.lineWidth <- width\r\n    ctx.beginPath()\r\n    path.Invoke(line) |> ignore\r\n    if fill then ctx.fill() else ctx.stroke()\r\n\r\n  /// Render background, current country, borders & globe\r\n  let render country angle =\r\n      projection.rotate(unbox angle) |> ignore\r\n      ctx.clearRect(0., 0., width, height)\r\n      draw \"#ACA2AD\" 0.0 landFeature true\r\n      draw \"#9E4078\" 0.0 country true\r\n      draw \"#EAF1F7\" 0.5 borders false\r\n      draw \"#726B72\" 2.0 globe false\r\n      box ()\r\n(**\r\n\r\n### Creating the transition\r\n\r\nPerhaps the most interesting part of the demo is the next one. Here, we use D3\r\nto create the animated transition. This is done by calling `d3.transition()` and\r\nthen setting up a number of parameters:\r\n\r\n*)\r\n  let rec transition i =\r\n    d3.transition()\r\n      .duration(1250.)\r\n      .each(\"start\", f2 (fun _ _ ->\r\n        // Set the text of the HTML element\r\n        let name = unbox<D3.Primitive> countries.[i]?name\r\n        title.text(name) |> box ))\r\n      .tween(\"rotate\", f1 (fun _ ->\r\n        // Interopolate the rotation & return function\r\n        // that renders everything at a given time 't'\r\n        let p1, p2 = D3.geo.centroid(countries.[i])\r\n        let r = d3.interpolate(projection.rotate(), (-p1, -p2))\r\n        f1 (fun t -> render countries.[i] (r.Invoke(t))) ))\r\n      .transition()\r\n      .each(\"end\", f2 (fun _ _ ->\r\n        // At the end, start the transition again!\r\n        transition ((i + 1) % countries.Length) )) |> box\r\n(*** hide ***)\r\n  transition(0)\r\n(**\r\nLoading the data\r\n----------------\r\n\r\nThe last thing that we need to do in order to put everything together is to trigger the loading\r\nof data. This is done by calling `queue().defer(...)`, which specifies that a file should be\r\n(eventually) loaded. When the loading is done, we check for potential errors and call the\r\n`dataLoaded` function, which then starts the first transition.\r\n*)\r\nqueue()\r\n  // Use the dynamic operator here so the F# compiler\r\n  // doesn't wrap d3.json/d3.tsv in a lambda\r\n  .defer(d3?json, \"data/world-110m.json\")\r\n  .defer(d3?tsv, \"data/world-country-names.tsv\")\r\n  .await(f3 <| fun error world names ->\r\n    if error then error |> unbox |> raise\r\n    dataLoaded world names)\r\n"]}